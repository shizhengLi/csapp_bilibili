# 深入理解计算机系统（2）

## 第一次代码重构

### 可变参数输出print函数

功能：通过一些bitmap来设置打印哪些模块，如stack、register或者linker等，打印它们的值。这样做的好处是，不同的模块调用相同的`printf`函数，提高代码复用，方便debug。

```c
// ./src/common/print.c

#include<stdarg.h>   	// 主要用于可变参数函数
#include<stdio.h>
#include<assert.h>
#include<headers/common.h>

// wrapper of stdio printf  // wrapper封装的意思
// controlled by the debug verbose bit set
// open_set： 指明哪些模块需要调用printf函数
uint64_t debug_printf(uint64_t open_set, const char *format, ...)  // 可变参数函数
{
    if ((open_set & DEBUG_VERBOSE_SET) == 0x0)
    {
        return 0x1;
    }

    // implementation of std printf()
    va_list argptr;
    va_start(argptr, format);  // 初始化argptr变量
    vfprintf(stderr, format, argptr);  // 输出到stderr中
    va_end(argptr);		// 允许使用了va_start的可变参数函数返回,这里是vfprintf函数

    return 0x0;
}
```

`stdarg.h`标准库

>
>
>**`stdarg.h`**是[C语言](https://zh.wikipedia.org/wiki/C語言)中[C标准库](https://zh.wikipedia.org/wiki/C標準函式庫)的[头文件](https://zh.wikipedia.org/wiki/標頭檔)，`stdarg`是由**st**andar**d**（标准） **arg**uments（参数）简化而来，主要目的为让函数能够接收不定量参数。
>
>[不定参数函数](https://zh.wikipedia.org/wiki/不定參數函式)（`Variadic functions`）是`stdarg.h`内容典型的应用，虽然也可以使用在其他由不定参数函数调用的函数（例如，`vprintf`）。

来源：[stdarg.h](https://zh.wikipedia.org/wiki/Stdarg.h)

变量类型

```c
va_list：这是一个适用于 va_start()、va_arg() 和 va_end() 这三个宏存储信息的类型。
```

库宏

```c
void va_start(va_list ap, last_arg)
// 这个宏初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。

type va_arg(va_list ap, type)
// 这个宏检索函数参数列表中类型为 type 的下一个参数。

void va_end(va_list ap)
// 这个宏允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。    
```

另外关于`vfprintf`函数：根据参数列表将格式化输出写入到s中。

```c
/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
		     __gnuc_va_list __arg);
```



补充：bitmap是bit manipulation的简写，是通过bit来控制一些流程。

### bitmap学习

通过一些宏定义，来调用同一封装函数print（可变参数函数），提高代码复用。

通过一个`DEBUG_VERBOSE_SET`(废话程度)宏，来控制对哪个模块的debug输出。

```c
// 通过或运算(|)来打开不同的模块：
// 这里是打开DEBUG_INSTRUCTIONCYCLE,DEBUG_REGISTERS和DEBUG_LINKER的debug开关
#define DEBUG_VERBOSE_SET           0X1 | 0x2 | 0x40
```

具体debug宏定义如下：

```c
#ifndef DEBUG_GUARD
#define DEBUG_GUARD

#include <stdint.h>

#define DEBUG_INSTRUCTIONCYCLE      0x1		// 指令周期debug开关
#define DEBUG_REGISTERS             0x2		// 寄存器dubug开关		
#define DEBUG_PRINTSTACK            0x4		// 栈debug开关
#define DEBUG_PRINTCACHESET         0x8
#define DEBUG_CACHEDETAILS          0x10
#define DEBUG_MMU                   0x20
#define DEBUG_LINKER                0x40
#define DEBUG_LOADER                0x80
#define DEBUG_PARSEINST             0x100

// vorbose set 是废话程度，通过一个宏来控制哪些模块的打印输出
#define DEBUG_VERBOSE_SET           0X1  

// do page walk
#define DEBUG_ENABLE_PAGE_WALK      0

// user sram cache for memory access
#define DEBUG_ENABLE_SRAM_CACHE     0

// print wrapper print的封装
// open_set 填写需要debug的宏
uint64_t dubug_printf(uint64_t open_set, const char *format, ...);

#endif
```

### P10 有限自动机



解析字符串的状态机分析图：

![image-20220120170207502](https://raw.githubusercontent.com/shizhengLi/image_bed_01/main/img/image-20220120170207502.png)



小括号：parenthesis

![ ](https://raw.githubusercontent.com/shizhengLi/image_bed_01/main/img/image-20220108183234342.png)

### P11

更新cpu的标志位定义

使用结构体来定义`CPU_FLAGS_STRUCT`。其中，使用union结构共享内存：让`__cpu_flag_values`(64 bit)和四个标志位共享内存（16 bit exlusively）。这样初始化4个标志位的时候，直接`__cpu_flag_values =0`即可。代替`CF = 0, ZF = 0, SF = 0, OF = 0`。

```c
typedef struct CPU_FLAGS_STRUCT
{
    union
    {
        uint64_t __cpu_flag_values;
        struct 
        {
            // carry flag: detect overflow for unsigned operations
            uint16_t CF;
            // zero flag: result is zero
            uint16_t ZF;
            // sign flag: result is negative: highest bit
            uint16_t SF;
            // overflow flag: detect overflow for signed operations
            uint16_t OF;
        }; 
    };   
} cpu_flag_t;
```



指令解析完成，使用字符串的形式把(P1~P9)的工作又做了一遍。

由于sub指令还未实现，故产生如下输出，sub以上的部分是正确的。

```bash
begin
400400    mov    $0x3,%edi
400440    callq  0x00400000
400000    push   %rbp
400040    mov    %rsp,%rbp
400080    sub    $0x10,%rsp
400080    sub    $0x10,%rsp
```



c语言断言`assert`的使用

> ASSERT() 是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为 FALSE (0), 程序将报告错误，并终止执行。如果表达式不为 0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。
>
> **ASSERT 只有在 Debug 版本中才有效，如果编译为 Release 版本则被忽略**
>
> 来源：菜鸟教程



现在开始条件码（`conditon codes`）部分的代码



add函数设置标志位

加法有符号溢出的判断：`!(src_sign ^ dst_sign)&&(src_sign ^ val_sign)`：根据`src + dst = val` 三个数的标志位来确定有符号数溢出。

```c
static void add_handler(od_t *src_od, od_t *dst_od, core_t *cr)
{
    // ...
    
    int val_sign = ((val >> 63) & 0x1);
    int src_sign = ((src >> 63) & 0x1);
    int dst_sign = ((dst >> 63) & 0x1);

    // set condition flags
    cr->flags.ZF = (val == 0); 
    cr->flags.CF = (val < *((uint64_t *)src)); // unsigned
    cr->flags.SF = ((val >> 63) & 0x1);
    cr->flags.OF = (src_sign == 0 && dst_sign == 0 && val_sign == 1) || 
        (src_sign == 1 && dst_sign == 1 && val_sign == 0); // signed   
}

```

