# 深入理解计算机系统（3）

这一部分记录链接的知识点。

## 链接

### ELF目标文件

#### ELF header

可执行可链接格式（`Executable Linkable Format, ELF`）

`ELF header` 以一个`16B`的序列（该`16B`的序列称为魔数(`magic number`)）开始，描述了生成该文件的系统的字(word)的大小和字节顺序(大端机还是小端机)。

![image-20220124123111103](https://raw.githubusercontent.com/shizhengLi/image_bed_01/main/img/image-20220124123111103.png)



`sh是section header的简写`，`rodata是read only data的简写`。`SHT 是 section header table的简写。`

下面是具体的`ELF header` 的结构定义：

```c
typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */			// 128 bit
  Elf64_Half	e_type;			/* Object file type */  						// 16 bit
  Elf64_Half	e_machine;		/* Architecture */								// 32 bit		
  Elf64_Word	e_version;		/* Object file version */  						// 32 bit
  Elf64_Addr	e_entry;		/* Entry point virtual address */  				// 64 bit
  Elf64_Off	e_phoff;		/* Program header table file offset */  			// 64 bit
  Elf64_Off	e_shoff;		/* Section header table file offset */  			// 64 bit
  Elf64_Word	e_flags;		/* Processor-specific flags */					// 32 bit
  Elf64_Half	e_ehsize;		/* ELF header size in bytes */					// 16 bit
  Elf64_Half	e_phentsize;		/* Program header table entry size */		// 16 bit
  Elf64_Half	e_phnum;		/* Program header table entry count */			// 16 bit
  Elf64_Half	e_shentsize;		/* Section header table entry size */		// 16 bit
  Elf64_Half	e_shnum;		/* Section header table entry count */			// 16 bit
  Elf64_Half	e_shstrndx;		/* Section header string table index */			// 16 bit
} Elf64_Ehdr;
```

由我们使用`hexdump`得到的二进制文件，使用十六进制打印出来（每行`16B`）：

![image-20220124160748115](https://raw.githubusercontent.com/shizhengLi/image_bed_01/main/img/image-20220124160748115.png)

这里展示前4行，即ELF header具体存储的内容（注意这里是小端机，低地址在前，高地址在后）：

```bash
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..>.............|
00000020  00 00 00 00 00 00 00 00  00 03 00 00 00 00 00 00  |................|
00000030  00 00 00 00 40 00 00 00  00 00 40 00 0c 00 0b 00  |....@.....@.....|
```



第一行的内容：

```bash
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
```

第一行`16B`是`magic number`（魔数），变量名是`e_ident`，这里值是 `0x010102464c457f`；



第二行的内容：

```bash
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..>.............|
```

第二行前`2B`，表示的是`Object file type`（目标文件类型），变量名为`e_type`，这里值是 `0x0001`；

接下来`2B`，表示的是`machine architecture`（指令集），变量名是`e_machine`，这里值是`0x003e`；

接下来`4B`，表示的是 `Object file version` （目标文件版本号），变量名是`e_version`，这里值是`0x00000001`;

后面的`8B`，表示的是`Entry point virtual address`（表项点虚拟地址），变量名是`e_entry`，这里值是`0x0000000000000000`。



第三行的内容：

```bash
00000020  00 00 00 00 00 00 00 00  00 03 00 00 00 00 00 00  |................|
```

第三行的内容分为两个`8B`，

第二行前`8B`，表示的是`Program header table file offset`（程序头表的偏移），变量名为`e_phoff`，这里值是 `0x0`；

接下来`8B`，表示的是`Section header table file offset`（**节头表的偏移**），变量名为`e_shoff`，这里值是 `0x0300`；

这里我们关心的是后者：`section header table`（简称`SHT`） 的offset 是`0x300`。它的含义是`SHT`这张表的起始地址偏移`ELF header`的多少。比如这里`SHT`这张表的起始地址从`ELF header`偏移`0x300字节`的地方开始存放的。



第四行的内容：

```bash
00000030  00 00 00 00 40 00 00 00  00 00 40 00 0c 00 0b 00  |....@.....@.....|
```

第四行前`4B`，表示的是`Processor-specific flags`（处理器相关的标志），变量名为`e_flags`，这里值是 `0x0`；

接下来`2B`，表示的是`ELF header size in bytes`（**ELF头的大小**），变量名为`e_ehsize`，这里值是 `0x40`,即ELF头大小为`64B`；对应上面的4行。上面的4行就是整个ELF header的内容。

接下来`2B`，表示的是`Program header table entry size`（程序头表的表项的大小），变量名为`e_phentsize`，这里值是 `0x0`，因为目前不是可执行文件，故还没有到程序运行时，此时这些值都是0;

接下来`2B`，表示的是`Program header table entry count`（程序头表表项的数量），变量名为`e_phnum`，这里值是 `0x0`；

接下来`2B`，表示的是`Section header table entry size`（**节头表表项的大小**），变量名为`e_shentsize`，这里值是 `0x40`；

接下来`2B`，表示的是`Section header table entry count`（**节头表表项的数量**），变量名为`e_shnum`，这里值是 `0x0c`；

接下来`2B`，表示的是`Section header string table index`（节头字符串表的索引），变量名为`e_shstrndx`，这里值是 `0x0b`；

上面是我们自己根据结构体定义逐个匹配的，当然在系统中使用`readelf`命令也可以查看上述信息：

![image-20220124170932767](https://raw.githubusercontent.com/shizhengLi/image_bed_01/main/img/image-20220124170932767.png)

再来复习一下ELF可重定位目标文件的结构

![image-20220124170306586](https://raw.githubusercontent.com/shizhengLi/image_bed_01/main/img/image-20220124170306586.png)



这里的ELF header也是section的一部分。

#### `hexdump`使用



代码尝试生成不链接的文件，使用`-c`参数。

```bash
$ gcc -c elf.c -o elf.o  # 将elf.c编译、汇编，但是不进行链接
```

`hexdump`是按照我们的需要打印16进制的利器，下面是需要的参数

```bash
 -c      One-byte character display.  Display the input offset in hexadecimal, followed by sixteen space-separated, three column, space-filled, characters of input data per line.

     -C      Canonical hex+ASCII display.  Display the input offset in hexadecimal, followed by sixteen space-separated, two column, hexadecimal bytes, followed by the same sixteen
             bytes in %_p format enclosed in ``|'' characters.

             Calling the command hd implies this option.

```

比如对于我们上面生成的`elf.o`文件，我们可以使用

```bash
$ hexdump -C elf.o
```

会按照偏移，后面跟着16个十六进制数，再后面是对应的`ascii`码。

比如：

```bash
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..>.............|
00000020  00 00 00 00 00 00 00 00  00 03 00 00 00 00 00 00  |................|
00000030  00 00 00 00 40 00 00 00  00 00 40 00 0c 00 0b 00  |....@.....@.....|
```



#### readelf命令的使用

```c
Usage: readelf <option(s)> elf-file(s)
 Display information about the contents of ELF format files
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
```

这里的用法是查看`elf.o`文件的file header

```c
readelf -h elf.o
```

得到的结果

```bash
azheng@lishizheng:/mnt/e/csapp_bilibili/ass_first_refactory/test$ readelf -h elf.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          768 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         12
  Section header string table index: 11
```

